/*
FastAPI

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// OllamaAPIService OllamaAPI service
type OllamaAPIService service

type ApiCopyModelOllamaApiCopyPostRequest struct {
	ctx context.Context
	ApiService *OllamaAPIService
	copyModelForm *CopyModelForm
	urlIdx *int32
}

func (r ApiCopyModelOllamaApiCopyPostRequest) CopyModelForm(copyModelForm CopyModelForm) ApiCopyModelOllamaApiCopyPostRequest {
	r.copyModelForm = &copyModelForm
	return r
}

func (r ApiCopyModelOllamaApiCopyPostRequest) UrlIdx(urlIdx int32) ApiCopyModelOllamaApiCopyPostRequest {
	r.urlIdx = &urlIdx
	return r
}

func (r ApiCopyModelOllamaApiCopyPostRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.CopyModelOllamaApiCopyPostExecute(r)
}

/*
CopyModelOllamaApiCopyPost Copy Model

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCopyModelOllamaApiCopyPostRequest
*/
func (a *OllamaAPIService) CopyModelOllamaApiCopyPost(ctx context.Context) ApiCopyModelOllamaApiCopyPostRequest {
	return ApiCopyModelOllamaApiCopyPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OllamaAPIService) CopyModelOllamaApiCopyPostExecute(r ApiCopyModelOllamaApiCopyPostRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OllamaAPIService.CopyModelOllamaApiCopyPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ollama/api/copy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.copyModelForm == nil {
		return localVarReturnValue, nil, reportError("copyModelForm is required and must be specified")
	}

	if r.urlIdx != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "url_idx", r.urlIdx, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.copyModelForm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCopyModelOllamaApiCopyUrlIdxPostRequest struct {
	ctx context.Context
	ApiService *OllamaAPIService
	urlIdx int32
	copyModelForm *CopyModelForm
}

func (r ApiCopyModelOllamaApiCopyUrlIdxPostRequest) CopyModelForm(copyModelForm CopyModelForm) ApiCopyModelOllamaApiCopyUrlIdxPostRequest {
	r.copyModelForm = &copyModelForm
	return r
}

func (r ApiCopyModelOllamaApiCopyUrlIdxPostRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.CopyModelOllamaApiCopyUrlIdxPostExecute(r)
}

/*
CopyModelOllamaApiCopyUrlIdxPost Copy Model

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param urlIdx
 @return ApiCopyModelOllamaApiCopyUrlIdxPostRequest
*/
func (a *OllamaAPIService) CopyModelOllamaApiCopyUrlIdxPost(ctx context.Context, urlIdx int32) ApiCopyModelOllamaApiCopyUrlIdxPostRequest {
	return ApiCopyModelOllamaApiCopyUrlIdxPostRequest{
		ApiService: a,
		ctx: ctx,
		urlIdx: urlIdx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OllamaAPIService) CopyModelOllamaApiCopyUrlIdxPostExecute(r ApiCopyModelOllamaApiCopyUrlIdxPostRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OllamaAPIService.CopyModelOllamaApiCopyUrlIdxPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ollama/api/copy/{url_idx}"
	localVarPath = strings.Replace(localVarPath, "{"+"url_idx"+"}", url.PathEscape(parameterValueToString(r.urlIdx, "urlIdx")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.copyModelForm == nil {
		return localVarReturnValue, nil, reportError("copyModelForm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.copyModelForm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateModelOllamaApiCreatePostRequest struct {
	ctx context.Context
	ApiService *OllamaAPIService
	createModelForm *CreateModelForm
	urlIdx *int32
}

func (r ApiCreateModelOllamaApiCreatePostRequest) CreateModelForm(createModelForm CreateModelForm) ApiCreateModelOllamaApiCreatePostRequest {
	r.createModelForm = &createModelForm
	return r
}

func (r ApiCreateModelOllamaApiCreatePostRequest) UrlIdx(urlIdx int32) ApiCreateModelOllamaApiCreatePostRequest {
	r.urlIdx = &urlIdx
	return r
}

func (r ApiCreateModelOllamaApiCreatePostRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.CreateModelOllamaApiCreatePostExecute(r)
}

/*
CreateModelOllamaApiCreatePost Create Model

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateModelOllamaApiCreatePostRequest
*/
func (a *OllamaAPIService) CreateModelOllamaApiCreatePost(ctx context.Context) ApiCreateModelOllamaApiCreatePostRequest {
	return ApiCreateModelOllamaApiCreatePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OllamaAPIService) CreateModelOllamaApiCreatePostExecute(r ApiCreateModelOllamaApiCreatePostRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OllamaAPIService.CreateModelOllamaApiCreatePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ollama/api/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createModelForm == nil {
		return localVarReturnValue, nil, reportError("createModelForm is required and must be specified")
	}

	if r.urlIdx != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "url_idx", r.urlIdx, "form", "")
	} else {
		var defaultValue int32 = 0
		r.urlIdx = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createModelForm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateModelOllamaApiCreateUrlIdxPostRequest struct {
	ctx context.Context
	ApiService *OllamaAPIService
	urlIdx int32
	createModelForm *CreateModelForm
}

func (r ApiCreateModelOllamaApiCreateUrlIdxPostRequest) CreateModelForm(createModelForm CreateModelForm) ApiCreateModelOllamaApiCreateUrlIdxPostRequest {
	r.createModelForm = &createModelForm
	return r
}

func (r ApiCreateModelOllamaApiCreateUrlIdxPostRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.CreateModelOllamaApiCreateUrlIdxPostExecute(r)
}

/*
CreateModelOllamaApiCreateUrlIdxPost Create Model

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param urlIdx
 @return ApiCreateModelOllamaApiCreateUrlIdxPostRequest
*/
func (a *OllamaAPIService) CreateModelOllamaApiCreateUrlIdxPost(ctx context.Context, urlIdx int32) ApiCreateModelOllamaApiCreateUrlIdxPostRequest {
	return ApiCreateModelOllamaApiCreateUrlIdxPostRequest{
		ApiService: a,
		ctx: ctx,
		urlIdx: urlIdx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OllamaAPIService) CreateModelOllamaApiCreateUrlIdxPostExecute(r ApiCreateModelOllamaApiCreateUrlIdxPostRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OllamaAPIService.CreateModelOllamaApiCreateUrlIdxPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ollama/api/create/{url_idx}"
	localVarPath = strings.Replace(localVarPath, "{"+"url_idx"+"}", url.PathEscape(parameterValueToString(r.urlIdx, "urlIdx")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createModelForm == nil {
		return localVarReturnValue, nil, reportError("createModelForm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createModelForm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteModelOllamaApiDeleteDeleteRequest struct {
	ctx context.Context
	ApiService *OllamaAPIService
	modelNameForm *ModelNameForm
	urlIdx *int32
}

func (r ApiDeleteModelOllamaApiDeleteDeleteRequest) ModelNameForm(modelNameForm ModelNameForm) ApiDeleteModelOllamaApiDeleteDeleteRequest {
	r.modelNameForm = &modelNameForm
	return r
}

func (r ApiDeleteModelOllamaApiDeleteDeleteRequest) UrlIdx(urlIdx int32) ApiDeleteModelOllamaApiDeleteDeleteRequest {
	r.urlIdx = &urlIdx
	return r
}

func (r ApiDeleteModelOllamaApiDeleteDeleteRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.DeleteModelOllamaApiDeleteDeleteExecute(r)
}

/*
DeleteModelOllamaApiDeleteDelete Delete Model

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteModelOllamaApiDeleteDeleteRequest
*/
func (a *OllamaAPIService) DeleteModelOllamaApiDeleteDelete(ctx context.Context) ApiDeleteModelOllamaApiDeleteDeleteRequest {
	return ApiDeleteModelOllamaApiDeleteDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OllamaAPIService) DeleteModelOllamaApiDeleteDeleteExecute(r ApiDeleteModelOllamaApiDeleteDeleteRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OllamaAPIService.DeleteModelOllamaApiDeleteDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ollama/api/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelNameForm == nil {
		return localVarReturnValue, nil, reportError("modelNameForm is required and must be specified")
	}

	if r.urlIdx != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "url_idx", r.urlIdx, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelNameForm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteModelOllamaApiDeleteUrlIdxDeleteRequest struct {
	ctx context.Context
	ApiService *OllamaAPIService
	urlIdx int32
	modelNameForm *ModelNameForm
}

func (r ApiDeleteModelOllamaApiDeleteUrlIdxDeleteRequest) ModelNameForm(modelNameForm ModelNameForm) ApiDeleteModelOllamaApiDeleteUrlIdxDeleteRequest {
	r.modelNameForm = &modelNameForm
	return r
}

func (r ApiDeleteModelOllamaApiDeleteUrlIdxDeleteRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.DeleteModelOllamaApiDeleteUrlIdxDeleteExecute(r)
}

/*
DeleteModelOllamaApiDeleteUrlIdxDelete Delete Model

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param urlIdx
 @return ApiDeleteModelOllamaApiDeleteUrlIdxDeleteRequest
*/
func (a *OllamaAPIService) DeleteModelOllamaApiDeleteUrlIdxDelete(ctx context.Context, urlIdx int32) ApiDeleteModelOllamaApiDeleteUrlIdxDeleteRequest {
	return ApiDeleteModelOllamaApiDeleteUrlIdxDeleteRequest{
		ApiService: a,
		ctx: ctx,
		urlIdx: urlIdx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OllamaAPIService) DeleteModelOllamaApiDeleteUrlIdxDeleteExecute(r ApiDeleteModelOllamaApiDeleteUrlIdxDeleteRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OllamaAPIService.DeleteModelOllamaApiDeleteUrlIdxDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ollama/api/delete/{url_idx}"
	localVarPath = strings.Replace(localVarPath, "{"+"url_idx"+"}", url.PathEscape(parameterValueToString(r.urlIdx, "urlIdx")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelNameForm == nil {
		return localVarReturnValue, nil, reportError("modelNameForm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelNameForm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadModelOllamaModelsDownloadPostRequest struct {
	ctx context.Context
	ApiService *OllamaAPIService
	urlForm *UrlForm
	urlIdx *int32
}

func (r ApiDownloadModelOllamaModelsDownloadPostRequest) UrlForm(urlForm UrlForm) ApiDownloadModelOllamaModelsDownloadPostRequest {
	r.urlForm = &urlForm
	return r
}

func (r ApiDownloadModelOllamaModelsDownloadPostRequest) UrlIdx(urlIdx int32) ApiDownloadModelOllamaModelsDownloadPostRequest {
	r.urlIdx = &urlIdx
	return r
}

func (r ApiDownloadModelOllamaModelsDownloadPostRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.DownloadModelOllamaModelsDownloadPostExecute(r)
}

/*
DownloadModelOllamaModelsDownloadPost Download Model

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDownloadModelOllamaModelsDownloadPostRequest
*/
func (a *OllamaAPIService) DownloadModelOllamaModelsDownloadPost(ctx context.Context) ApiDownloadModelOllamaModelsDownloadPostRequest {
	return ApiDownloadModelOllamaModelsDownloadPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OllamaAPIService) DownloadModelOllamaModelsDownloadPostExecute(r ApiDownloadModelOllamaModelsDownloadPostRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OllamaAPIService.DownloadModelOllamaModelsDownloadPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ollama/models/download"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.urlForm == nil {
		return localVarReturnValue, nil, reportError("urlForm is required and must be specified")
	}

	if r.urlIdx != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "url_idx", r.urlIdx, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.urlForm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadModelOllamaModelsDownloadUrlIdxPostRequest struct {
	ctx context.Context
	ApiService *OllamaAPIService
	urlIdx int32
	urlForm *UrlForm
}

func (r ApiDownloadModelOllamaModelsDownloadUrlIdxPostRequest) UrlForm(urlForm UrlForm) ApiDownloadModelOllamaModelsDownloadUrlIdxPostRequest {
	r.urlForm = &urlForm
	return r
}

func (r ApiDownloadModelOllamaModelsDownloadUrlIdxPostRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.DownloadModelOllamaModelsDownloadUrlIdxPostExecute(r)
}

/*
DownloadModelOllamaModelsDownloadUrlIdxPost Download Model

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param urlIdx
 @return ApiDownloadModelOllamaModelsDownloadUrlIdxPostRequest
*/
func (a *OllamaAPIService) DownloadModelOllamaModelsDownloadUrlIdxPost(ctx context.Context, urlIdx int32) ApiDownloadModelOllamaModelsDownloadUrlIdxPostRequest {
	return ApiDownloadModelOllamaModelsDownloadUrlIdxPostRequest{
		ApiService: a,
		ctx: ctx,
		urlIdx: urlIdx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OllamaAPIService) DownloadModelOllamaModelsDownloadUrlIdxPostExecute(r ApiDownloadModelOllamaModelsDownloadUrlIdxPostRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OllamaAPIService.DownloadModelOllamaModelsDownloadUrlIdxPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ollama/models/download/{url_idx}"
	localVarPath = strings.Replace(localVarPath, "{"+"url_idx"+"}", url.PathEscape(parameterValueToString(r.urlIdx, "urlIdx")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.urlForm == nil {
		return localVarReturnValue, nil, reportError("urlForm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.urlForm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEmbedOllamaApiEmbedPostRequest struct {
	ctx context.Context
	ApiService *OllamaAPIService
	generateEmbedForm *GenerateEmbedForm
	urlIdx *int32
}

func (r ApiEmbedOllamaApiEmbedPostRequest) GenerateEmbedForm(generateEmbedForm GenerateEmbedForm) ApiEmbedOllamaApiEmbedPostRequest {
	r.generateEmbedForm = &generateEmbedForm
	return r
}

func (r ApiEmbedOllamaApiEmbedPostRequest) UrlIdx(urlIdx int32) ApiEmbedOllamaApiEmbedPostRequest {
	r.urlIdx = &urlIdx
	return r
}

func (r ApiEmbedOllamaApiEmbedPostRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.EmbedOllamaApiEmbedPostExecute(r)
}

/*
EmbedOllamaApiEmbedPost Embed

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEmbedOllamaApiEmbedPostRequest
*/
func (a *OllamaAPIService) EmbedOllamaApiEmbedPost(ctx context.Context) ApiEmbedOllamaApiEmbedPostRequest {
	return ApiEmbedOllamaApiEmbedPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OllamaAPIService) EmbedOllamaApiEmbedPostExecute(r ApiEmbedOllamaApiEmbedPostRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OllamaAPIService.EmbedOllamaApiEmbedPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ollama/api/embed"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.generateEmbedForm == nil {
		return localVarReturnValue, nil, reportError("generateEmbedForm is required and must be specified")
	}

	if r.urlIdx != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "url_idx", r.urlIdx, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.generateEmbedForm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEmbedOllamaApiEmbedUrlIdxPostRequest struct {
	ctx context.Context
	ApiService *OllamaAPIService
	urlIdx int32
	generateEmbedForm *GenerateEmbedForm
}

func (r ApiEmbedOllamaApiEmbedUrlIdxPostRequest) GenerateEmbedForm(generateEmbedForm GenerateEmbedForm) ApiEmbedOllamaApiEmbedUrlIdxPostRequest {
	r.generateEmbedForm = &generateEmbedForm
	return r
}

func (r ApiEmbedOllamaApiEmbedUrlIdxPostRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.EmbedOllamaApiEmbedUrlIdxPostExecute(r)
}

/*
EmbedOllamaApiEmbedUrlIdxPost Embed

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param urlIdx
 @return ApiEmbedOllamaApiEmbedUrlIdxPostRequest
*/
func (a *OllamaAPIService) EmbedOllamaApiEmbedUrlIdxPost(ctx context.Context, urlIdx int32) ApiEmbedOllamaApiEmbedUrlIdxPostRequest {
	return ApiEmbedOllamaApiEmbedUrlIdxPostRequest{
		ApiService: a,
		ctx: ctx,
		urlIdx: urlIdx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OllamaAPIService) EmbedOllamaApiEmbedUrlIdxPostExecute(r ApiEmbedOllamaApiEmbedUrlIdxPostRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OllamaAPIService.EmbedOllamaApiEmbedUrlIdxPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ollama/api/embed/{url_idx}"
	localVarPath = strings.Replace(localVarPath, "{"+"url_idx"+"}", url.PathEscape(parameterValueToString(r.urlIdx, "urlIdx")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.generateEmbedForm == nil {
		return localVarReturnValue, nil, reportError("generateEmbedForm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.generateEmbedForm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEmbeddingsOllamaApiEmbeddingsPostRequest struct {
	ctx context.Context
	ApiService *OllamaAPIService
	generateEmbeddingsForm *GenerateEmbeddingsForm
	urlIdx *int32
}

func (r ApiEmbeddingsOllamaApiEmbeddingsPostRequest) GenerateEmbeddingsForm(generateEmbeddingsForm GenerateEmbeddingsForm) ApiEmbeddingsOllamaApiEmbeddingsPostRequest {
	r.generateEmbeddingsForm = &generateEmbeddingsForm
	return r
}

func (r ApiEmbeddingsOllamaApiEmbeddingsPostRequest) UrlIdx(urlIdx int32) ApiEmbeddingsOllamaApiEmbeddingsPostRequest {
	r.urlIdx = &urlIdx
	return r
}

func (r ApiEmbeddingsOllamaApiEmbeddingsPostRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.EmbeddingsOllamaApiEmbeddingsPostExecute(r)
}

/*
EmbeddingsOllamaApiEmbeddingsPost Embeddings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEmbeddingsOllamaApiEmbeddingsPostRequest
*/
func (a *OllamaAPIService) EmbeddingsOllamaApiEmbeddingsPost(ctx context.Context) ApiEmbeddingsOllamaApiEmbeddingsPostRequest {
	return ApiEmbeddingsOllamaApiEmbeddingsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OllamaAPIService) EmbeddingsOllamaApiEmbeddingsPostExecute(r ApiEmbeddingsOllamaApiEmbeddingsPostRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OllamaAPIService.EmbeddingsOllamaApiEmbeddingsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ollama/api/embeddings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.generateEmbeddingsForm == nil {
		return localVarReturnValue, nil, reportError("generateEmbeddingsForm is required and must be specified")
	}

	if r.urlIdx != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "url_idx", r.urlIdx, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.generateEmbeddingsForm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEmbeddingsOllamaApiEmbeddingsUrlIdxPostRequest struct {
	ctx context.Context
	ApiService *OllamaAPIService
	urlIdx int32
	generateEmbeddingsForm *GenerateEmbeddingsForm
}

func (r ApiEmbeddingsOllamaApiEmbeddingsUrlIdxPostRequest) GenerateEmbeddingsForm(generateEmbeddingsForm GenerateEmbeddingsForm) ApiEmbeddingsOllamaApiEmbeddingsUrlIdxPostRequest {
	r.generateEmbeddingsForm = &generateEmbeddingsForm
	return r
}

func (r ApiEmbeddingsOllamaApiEmbeddingsUrlIdxPostRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.EmbeddingsOllamaApiEmbeddingsUrlIdxPostExecute(r)
}

/*
EmbeddingsOllamaApiEmbeddingsUrlIdxPost Embeddings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param urlIdx
 @return ApiEmbeddingsOllamaApiEmbeddingsUrlIdxPostRequest
*/
func (a *OllamaAPIService) EmbeddingsOllamaApiEmbeddingsUrlIdxPost(ctx context.Context, urlIdx int32) ApiEmbeddingsOllamaApiEmbeddingsUrlIdxPostRequest {
	return ApiEmbeddingsOllamaApiEmbeddingsUrlIdxPostRequest{
		ApiService: a,
		ctx: ctx,
		urlIdx: urlIdx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OllamaAPIService) EmbeddingsOllamaApiEmbeddingsUrlIdxPostExecute(r ApiEmbeddingsOllamaApiEmbeddingsUrlIdxPostRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OllamaAPIService.EmbeddingsOllamaApiEmbeddingsUrlIdxPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ollama/api/embeddings/{url_idx}"
	localVarPath = strings.Replace(localVarPath, "{"+"url_idx"+"}", url.PathEscape(parameterValueToString(r.urlIdx, "urlIdx")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.generateEmbeddingsForm == nil {
		return localVarReturnValue, nil, reportError("generateEmbeddingsForm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.generateEmbeddingsForm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGenerateChatCompletionOllamaApiChatPostRequest struct {
	ctx context.Context
	ApiService *OllamaAPIService
	body *map[string]interface{}
	urlIdx *int32
	bypassFilter *bool
}

func (r ApiGenerateChatCompletionOllamaApiChatPostRequest) Body(body map[string]interface{}) ApiGenerateChatCompletionOllamaApiChatPostRequest {
	r.body = &body
	return r
}

func (r ApiGenerateChatCompletionOllamaApiChatPostRequest) UrlIdx(urlIdx int32) ApiGenerateChatCompletionOllamaApiChatPostRequest {
	r.urlIdx = &urlIdx
	return r
}

func (r ApiGenerateChatCompletionOllamaApiChatPostRequest) BypassFilter(bypassFilter bool) ApiGenerateChatCompletionOllamaApiChatPostRequest {
	r.bypassFilter = &bypassFilter
	return r
}

func (r ApiGenerateChatCompletionOllamaApiChatPostRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.GenerateChatCompletionOllamaApiChatPostExecute(r)
}

/*
GenerateChatCompletionOllamaApiChatPost Generate Chat Completion

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGenerateChatCompletionOllamaApiChatPostRequest
*/
func (a *OllamaAPIService) GenerateChatCompletionOllamaApiChatPost(ctx context.Context) ApiGenerateChatCompletionOllamaApiChatPostRequest {
	return ApiGenerateChatCompletionOllamaApiChatPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OllamaAPIService) GenerateChatCompletionOllamaApiChatPostExecute(r ApiGenerateChatCompletionOllamaApiChatPostRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OllamaAPIService.GenerateChatCompletionOllamaApiChatPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ollama/api/chat"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.urlIdx != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "url_idx", r.urlIdx, "form", "")
	}
	if r.bypassFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bypass_filter", r.bypassFilter, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGenerateChatCompletionOllamaApiChatUrlIdxPostRequest struct {
	ctx context.Context
	ApiService *OllamaAPIService
	urlIdx int32
	body *map[string]interface{}
	bypassFilter *bool
}

func (r ApiGenerateChatCompletionOllamaApiChatUrlIdxPostRequest) Body(body map[string]interface{}) ApiGenerateChatCompletionOllamaApiChatUrlIdxPostRequest {
	r.body = &body
	return r
}

func (r ApiGenerateChatCompletionOllamaApiChatUrlIdxPostRequest) BypassFilter(bypassFilter bool) ApiGenerateChatCompletionOllamaApiChatUrlIdxPostRequest {
	r.bypassFilter = &bypassFilter
	return r
}

func (r ApiGenerateChatCompletionOllamaApiChatUrlIdxPostRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.GenerateChatCompletionOllamaApiChatUrlIdxPostExecute(r)
}

/*
GenerateChatCompletionOllamaApiChatUrlIdxPost Generate Chat Completion

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param urlIdx
 @return ApiGenerateChatCompletionOllamaApiChatUrlIdxPostRequest
*/
func (a *OllamaAPIService) GenerateChatCompletionOllamaApiChatUrlIdxPost(ctx context.Context, urlIdx int32) ApiGenerateChatCompletionOllamaApiChatUrlIdxPostRequest {
	return ApiGenerateChatCompletionOllamaApiChatUrlIdxPostRequest{
		ApiService: a,
		ctx: ctx,
		urlIdx: urlIdx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OllamaAPIService) GenerateChatCompletionOllamaApiChatUrlIdxPostExecute(r ApiGenerateChatCompletionOllamaApiChatUrlIdxPostRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OllamaAPIService.GenerateChatCompletionOllamaApiChatUrlIdxPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ollama/api/chat/{url_idx}"
	localVarPath = strings.Replace(localVarPath, "{"+"url_idx"+"}", url.PathEscape(parameterValueToString(r.urlIdx, "urlIdx")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.bypassFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bypass_filter", r.bypassFilter, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGenerateCompletionOllamaApiGeneratePostRequest struct {
	ctx context.Context
	ApiService *OllamaAPIService
	generateCompletionForm *GenerateCompletionForm
	urlIdx *int32
}

func (r ApiGenerateCompletionOllamaApiGeneratePostRequest) GenerateCompletionForm(generateCompletionForm GenerateCompletionForm) ApiGenerateCompletionOllamaApiGeneratePostRequest {
	r.generateCompletionForm = &generateCompletionForm
	return r
}

func (r ApiGenerateCompletionOllamaApiGeneratePostRequest) UrlIdx(urlIdx int32) ApiGenerateCompletionOllamaApiGeneratePostRequest {
	r.urlIdx = &urlIdx
	return r
}

func (r ApiGenerateCompletionOllamaApiGeneratePostRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.GenerateCompletionOllamaApiGeneratePostExecute(r)
}

/*
GenerateCompletionOllamaApiGeneratePost Generate Completion

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGenerateCompletionOllamaApiGeneratePostRequest
*/
func (a *OllamaAPIService) GenerateCompletionOllamaApiGeneratePost(ctx context.Context) ApiGenerateCompletionOllamaApiGeneratePostRequest {
	return ApiGenerateCompletionOllamaApiGeneratePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OllamaAPIService) GenerateCompletionOllamaApiGeneratePostExecute(r ApiGenerateCompletionOllamaApiGeneratePostRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OllamaAPIService.GenerateCompletionOllamaApiGeneratePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ollama/api/generate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.generateCompletionForm == nil {
		return localVarReturnValue, nil, reportError("generateCompletionForm is required and must be specified")
	}

	if r.urlIdx != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "url_idx", r.urlIdx, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.generateCompletionForm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGenerateCompletionOllamaApiGenerateUrlIdxPostRequest struct {
	ctx context.Context
	ApiService *OllamaAPIService
	urlIdx int32
	generateCompletionForm *GenerateCompletionForm
}

func (r ApiGenerateCompletionOllamaApiGenerateUrlIdxPostRequest) GenerateCompletionForm(generateCompletionForm GenerateCompletionForm) ApiGenerateCompletionOllamaApiGenerateUrlIdxPostRequest {
	r.generateCompletionForm = &generateCompletionForm
	return r
}

func (r ApiGenerateCompletionOllamaApiGenerateUrlIdxPostRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.GenerateCompletionOllamaApiGenerateUrlIdxPostExecute(r)
}

/*
GenerateCompletionOllamaApiGenerateUrlIdxPost Generate Completion

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param urlIdx
 @return ApiGenerateCompletionOllamaApiGenerateUrlIdxPostRequest
*/
func (a *OllamaAPIService) GenerateCompletionOllamaApiGenerateUrlIdxPost(ctx context.Context, urlIdx int32) ApiGenerateCompletionOllamaApiGenerateUrlIdxPostRequest {
	return ApiGenerateCompletionOllamaApiGenerateUrlIdxPostRequest{
		ApiService: a,
		ctx: ctx,
		urlIdx: urlIdx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OllamaAPIService) GenerateCompletionOllamaApiGenerateUrlIdxPostExecute(r ApiGenerateCompletionOllamaApiGenerateUrlIdxPostRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OllamaAPIService.GenerateCompletionOllamaApiGenerateUrlIdxPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ollama/api/generate/{url_idx}"
	localVarPath = strings.Replace(localVarPath, "{"+"url_idx"+"}", url.PathEscape(parameterValueToString(r.urlIdx, "urlIdx")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.generateCompletionForm == nil {
		return localVarReturnValue, nil, reportError("generateCompletionForm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.generateCompletionForm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGenerateOpenaiChatCompletionOllamaV1ChatCompletionsPostRequest struct {
	ctx context.Context
	ApiService *OllamaAPIService
	body *map[string]interface{}
	urlIdx *int32
}

func (r ApiGenerateOpenaiChatCompletionOllamaV1ChatCompletionsPostRequest) Body(body map[string]interface{}) ApiGenerateOpenaiChatCompletionOllamaV1ChatCompletionsPostRequest {
	r.body = &body
	return r
}

func (r ApiGenerateOpenaiChatCompletionOllamaV1ChatCompletionsPostRequest) UrlIdx(urlIdx int32) ApiGenerateOpenaiChatCompletionOllamaV1ChatCompletionsPostRequest {
	r.urlIdx = &urlIdx
	return r
}

func (r ApiGenerateOpenaiChatCompletionOllamaV1ChatCompletionsPostRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.GenerateOpenaiChatCompletionOllamaV1ChatCompletionsPostExecute(r)
}

/*
GenerateOpenaiChatCompletionOllamaV1ChatCompletionsPost Generate Openai Chat Completion

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGenerateOpenaiChatCompletionOllamaV1ChatCompletionsPostRequest
*/
func (a *OllamaAPIService) GenerateOpenaiChatCompletionOllamaV1ChatCompletionsPost(ctx context.Context) ApiGenerateOpenaiChatCompletionOllamaV1ChatCompletionsPostRequest {
	return ApiGenerateOpenaiChatCompletionOllamaV1ChatCompletionsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OllamaAPIService) GenerateOpenaiChatCompletionOllamaV1ChatCompletionsPostExecute(r ApiGenerateOpenaiChatCompletionOllamaV1ChatCompletionsPostRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OllamaAPIService.GenerateOpenaiChatCompletionOllamaV1ChatCompletionsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ollama/v1/chat/completions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.urlIdx != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "url_idx", r.urlIdx, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGenerateOpenaiChatCompletionOllamaV1ChatCompletionsUrlIdxPostRequest struct {
	ctx context.Context
	ApiService *OllamaAPIService
	urlIdx int32
	body *map[string]interface{}
}

func (r ApiGenerateOpenaiChatCompletionOllamaV1ChatCompletionsUrlIdxPostRequest) Body(body map[string]interface{}) ApiGenerateOpenaiChatCompletionOllamaV1ChatCompletionsUrlIdxPostRequest {
	r.body = &body
	return r
}

func (r ApiGenerateOpenaiChatCompletionOllamaV1ChatCompletionsUrlIdxPostRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.GenerateOpenaiChatCompletionOllamaV1ChatCompletionsUrlIdxPostExecute(r)
}

/*
GenerateOpenaiChatCompletionOllamaV1ChatCompletionsUrlIdxPost Generate Openai Chat Completion

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param urlIdx
 @return ApiGenerateOpenaiChatCompletionOllamaV1ChatCompletionsUrlIdxPostRequest
*/
func (a *OllamaAPIService) GenerateOpenaiChatCompletionOllamaV1ChatCompletionsUrlIdxPost(ctx context.Context, urlIdx int32) ApiGenerateOpenaiChatCompletionOllamaV1ChatCompletionsUrlIdxPostRequest {
	return ApiGenerateOpenaiChatCompletionOllamaV1ChatCompletionsUrlIdxPostRequest{
		ApiService: a,
		ctx: ctx,
		urlIdx: urlIdx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OllamaAPIService) GenerateOpenaiChatCompletionOllamaV1ChatCompletionsUrlIdxPostExecute(r ApiGenerateOpenaiChatCompletionOllamaV1ChatCompletionsUrlIdxPostRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OllamaAPIService.GenerateOpenaiChatCompletionOllamaV1ChatCompletionsUrlIdxPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ollama/v1/chat/completions/{url_idx}"
	localVarPath = strings.Replace(localVarPath, "{"+"url_idx"+"}", url.PathEscape(parameterValueToString(r.urlIdx, "urlIdx")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGenerateOpenaiCompletionOllamaV1CompletionsPostRequest struct {
	ctx context.Context
	ApiService *OllamaAPIService
	body *map[string]interface{}
	urlIdx *int32
}

func (r ApiGenerateOpenaiCompletionOllamaV1CompletionsPostRequest) Body(body map[string]interface{}) ApiGenerateOpenaiCompletionOllamaV1CompletionsPostRequest {
	r.body = &body
	return r
}

func (r ApiGenerateOpenaiCompletionOllamaV1CompletionsPostRequest) UrlIdx(urlIdx int32) ApiGenerateOpenaiCompletionOllamaV1CompletionsPostRequest {
	r.urlIdx = &urlIdx
	return r
}

func (r ApiGenerateOpenaiCompletionOllamaV1CompletionsPostRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.GenerateOpenaiCompletionOllamaV1CompletionsPostExecute(r)
}

/*
GenerateOpenaiCompletionOllamaV1CompletionsPost Generate Openai Completion

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGenerateOpenaiCompletionOllamaV1CompletionsPostRequest
*/
func (a *OllamaAPIService) GenerateOpenaiCompletionOllamaV1CompletionsPost(ctx context.Context) ApiGenerateOpenaiCompletionOllamaV1CompletionsPostRequest {
	return ApiGenerateOpenaiCompletionOllamaV1CompletionsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OllamaAPIService) GenerateOpenaiCompletionOllamaV1CompletionsPostExecute(r ApiGenerateOpenaiCompletionOllamaV1CompletionsPostRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OllamaAPIService.GenerateOpenaiCompletionOllamaV1CompletionsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ollama/v1/completions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.urlIdx != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "url_idx", r.urlIdx, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGenerateOpenaiCompletionOllamaV1CompletionsUrlIdxPostRequest struct {
	ctx context.Context
	ApiService *OllamaAPIService
	urlIdx int32
	body *map[string]interface{}
}

func (r ApiGenerateOpenaiCompletionOllamaV1CompletionsUrlIdxPostRequest) Body(body map[string]interface{}) ApiGenerateOpenaiCompletionOllamaV1CompletionsUrlIdxPostRequest {
	r.body = &body
	return r
}

func (r ApiGenerateOpenaiCompletionOllamaV1CompletionsUrlIdxPostRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.GenerateOpenaiCompletionOllamaV1CompletionsUrlIdxPostExecute(r)
}

/*
GenerateOpenaiCompletionOllamaV1CompletionsUrlIdxPost Generate Openai Completion

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param urlIdx
 @return ApiGenerateOpenaiCompletionOllamaV1CompletionsUrlIdxPostRequest
*/
func (a *OllamaAPIService) GenerateOpenaiCompletionOllamaV1CompletionsUrlIdxPost(ctx context.Context, urlIdx int32) ApiGenerateOpenaiCompletionOllamaV1CompletionsUrlIdxPostRequest {
	return ApiGenerateOpenaiCompletionOllamaV1CompletionsUrlIdxPostRequest{
		ApiService: a,
		ctx: ctx,
		urlIdx: urlIdx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OllamaAPIService) GenerateOpenaiCompletionOllamaV1CompletionsUrlIdxPostExecute(r ApiGenerateOpenaiCompletionOllamaV1CompletionsUrlIdxPostRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OllamaAPIService.GenerateOpenaiCompletionOllamaV1CompletionsUrlIdxPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ollama/v1/completions/{url_idx}"
	localVarPath = strings.Replace(localVarPath, "{"+"url_idx"+"}", url.PathEscape(parameterValueToString(r.urlIdx, "urlIdx")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConfigOllamaConfigGetRequest struct {
	ctx context.Context
	ApiService *OllamaAPIService
}

func (r ApiGetConfigOllamaConfigGetRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.GetConfigOllamaConfigGetExecute(r)
}

/*
GetConfigOllamaConfigGet Get Config

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetConfigOllamaConfigGetRequest
*/
func (a *OllamaAPIService) GetConfigOllamaConfigGet(ctx context.Context) ApiGetConfigOllamaConfigGetRequest {
	return ApiGetConfigOllamaConfigGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OllamaAPIService) GetConfigOllamaConfigGetExecute(r ApiGetConfigOllamaConfigGetRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OllamaAPIService.GetConfigOllamaConfigGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ollama/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOllamaLoadedModelsOllamaApiPsGetRequest struct {
	ctx context.Context
	ApiService *OllamaAPIService
}

func (r ApiGetOllamaLoadedModelsOllamaApiPsGetRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.GetOllamaLoadedModelsOllamaApiPsGetExecute(r)
}

/*
GetOllamaLoadedModelsOllamaApiPsGet Get Ollama Loaded Models

List models that are currently loaded into Ollama memory, and which node they are loaded on.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetOllamaLoadedModelsOllamaApiPsGetRequest
*/
func (a *OllamaAPIService) GetOllamaLoadedModelsOllamaApiPsGet(ctx context.Context) ApiGetOllamaLoadedModelsOllamaApiPsGetRequest {
	return ApiGetOllamaLoadedModelsOllamaApiPsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OllamaAPIService) GetOllamaLoadedModelsOllamaApiPsGetExecute(r ApiGetOllamaLoadedModelsOllamaApiPsGetRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OllamaAPIService.GetOllamaLoadedModelsOllamaApiPsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ollama/api/ps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOllamaTagsOllamaApiTagsGetRequest struct {
	ctx context.Context
	ApiService *OllamaAPIService
	urlIdx *int32
}

func (r ApiGetOllamaTagsOllamaApiTagsGetRequest) UrlIdx(urlIdx int32) ApiGetOllamaTagsOllamaApiTagsGetRequest {
	r.urlIdx = &urlIdx
	return r
}

func (r ApiGetOllamaTagsOllamaApiTagsGetRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.GetOllamaTagsOllamaApiTagsGetExecute(r)
}

/*
GetOllamaTagsOllamaApiTagsGet Get Ollama Tags

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetOllamaTagsOllamaApiTagsGetRequest
*/
func (a *OllamaAPIService) GetOllamaTagsOllamaApiTagsGet(ctx context.Context) ApiGetOllamaTagsOllamaApiTagsGetRequest {
	return ApiGetOllamaTagsOllamaApiTagsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OllamaAPIService) GetOllamaTagsOllamaApiTagsGetExecute(r ApiGetOllamaTagsOllamaApiTagsGetRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OllamaAPIService.GetOllamaTagsOllamaApiTagsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ollama/api/tags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.urlIdx != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "url_idx", r.urlIdx, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOllamaTagsOllamaApiTagsUrlIdxGetRequest struct {
	ctx context.Context
	ApiService *OllamaAPIService
	urlIdx int32
}

func (r ApiGetOllamaTagsOllamaApiTagsUrlIdxGetRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.GetOllamaTagsOllamaApiTagsUrlIdxGetExecute(r)
}

/*
GetOllamaTagsOllamaApiTagsUrlIdxGet Get Ollama Tags

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param urlIdx
 @return ApiGetOllamaTagsOllamaApiTagsUrlIdxGetRequest
*/
func (a *OllamaAPIService) GetOllamaTagsOllamaApiTagsUrlIdxGet(ctx context.Context, urlIdx int32) ApiGetOllamaTagsOllamaApiTagsUrlIdxGetRequest {
	return ApiGetOllamaTagsOllamaApiTagsUrlIdxGetRequest{
		ApiService: a,
		ctx: ctx,
		urlIdx: urlIdx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OllamaAPIService) GetOllamaTagsOllamaApiTagsUrlIdxGetExecute(r ApiGetOllamaTagsOllamaApiTagsUrlIdxGetRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OllamaAPIService.GetOllamaTagsOllamaApiTagsUrlIdxGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ollama/api/tags/{url_idx}"
	localVarPath = strings.Replace(localVarPath, "{"+"url_idx"+"}", url.PathEscape(parameterValueToString(r.urlIdx, "urlIdx")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOllamaVersionsOllamaApiVersionGetRequest struct {
	ctx context.Context
	ApiService *OllamaAPIService
	urlIdx *int32
}

func (r ApiGetOllamaVersionsOllamaApiVersionGetRequest) UrlIdx(urlIdx int32) ApiGetOllamaVersionsOllamaApiVersionGetRequest {
	r.urlIdx = &urlIdx
	return r
}

func (r ApiGetOllamaVersionsOllamaApiVersionGetRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.GetOllamaVersionsOllamaApiVersionGetExecute(r)
}

/*
GetOllamaVersionsOllamaApiVersionGet Get Ollama Versions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetOllamaVersionsOllamaApiVersionGetRequest
*/
func (a *OllamaAPIService) GetOllamaVersionsOllamaApiVersionGet(ctx context.Context) ApiGetOllamaVersionsOllamaApiVersionGetRequest {
	return ApiGetOllamaVersionsOllamaApiVersionGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OllamaAPIService) GetOllamaVersionsOllamaApiVersionGetExecute(r ApiGetOllamaVersionsOllamaApiVersionGetRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OllamaAPIService.GetOllamaVersionsOllamaApiVersionGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ollama/api/version"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.urlIdx != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "url_idx", r.urlIdx, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOllamaVersionsOllamaApiVersionUrlIdxGetRequest struct {
	ctx context.Context
	ApiService *OllamaAPIService
	urlIdx int32
}

func (r ApiGetOllamaVersionsOllamaApiVersionUrlIdxGetRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.GetOllamaVersionsOllamaApiVersionUrlIdxGetExecute(r)
}

/*
GetOllamaVersionsOllamaApiVersionUrlIdxGet Get Ollama Versions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param urlIdx
 @return ApiGetOllamaVersionsOllamaApiVersionUrlIdxGetRequest
*/
func (a *OllamaAPIService) GetOllamaVersionsOllamaApiVersionUrlIdxGet(ctx context.Context, urlIdx int32) ApiGetOllamaVersionsOllamaApiVersionUrlIdxGetRequest {
	return ApiGetOllamaVersionsOllamaApiVersionUrlIdxGetRequest{
		ApiService: a,
		ctx: ctx,
		urlIdx: urlIdx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OllamaAPIService) GetOllamaVersionsOllamaApiVersionUrlIdxGetExecute(r ApiGetOllamaVersionsOllamaApiVersionUrlIdxGetRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OllamaAPIService.GetOllamaVersionsOllamaApiVersionUrlIdxGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ollama/api/version/{url_idx}"
	localVarPath = strings.Replace(localVarPath, "{"+"url_idx"+"}", url.PathEscape(parameterValueToString(r.urlIdx, "urlIdx")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOpenaiModelsOllamaV1ModelsGetRequest struct {
	ctx context.Context
	ApiService *OllamaAPIService
	urlIdx *int32
}

func (r ApiGetOpenaiModelsOllamaV1ModelsGetRequest) UrlIdx(urlIdx int32) ApiGetOpenaiModelsOllamaV1ModelsGetRequest {
	r.urlIdx = &urlIdx
	return r
}

func (r ApiGetOpenaiModelsOllamaV1ModelsGetRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.GetOpenaiModelsOllamaV1ModelsGetExecute(r)
}

/*
GetOpenaiModelsOllamaV1ModelsGet Get Openai Models

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetOpenaiModelsOllamaV1ModelsGetRequest
*/
func (a *OllamaAPIService) GetOpenaiModelsOllamaV1ModelsGet(ctx context.Context) ApiGetOpenaiModelsOllamaV1ModelsGetRequest {
	return ApiGetOpenaiModelsOllamaV1ModelsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OllamaAPIService) GetOpenaiModelsOllamaV1ModelsGetExecute(r ApiGetOpenaiModelsOllamaV1ModelsGetRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OllamaAPIService.GetOpenaiModelsOllamaV1ModelsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ollama/v1/models"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.urlIdx != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "url_idx", r.urlIdx, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOpenaiModelsOllamaV1ModelsUrlIdxGetRequest struct {
	ctx context.Context
	ApiService *OllamaAPIService
	urlIdx int32
}

func (r ApiGetOpenaiModelsOllamaV1ModelsUrlIdxGetRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.GetOpenaiModelsOllamaV1ModelsUrlIdxGetExecute(r)
}

/*
GetOpenaiModelsOllamaV1ModelsUrlIdxGet Get Openai Models

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param urlIdx
 @return ApiGetOpenaiModelsOllamaV1ModelsUrlIdxGetRequest
*/
func (a *OllamaAPIService) GetOpenaiModelsOllamaV1ModelsUrlIdxGet(ctx context.Context, urlIdx int32) ApiGetOpenaiModelsOllamaV1ModelsUrlIdxGetRequest {
	return ApiGetOpenaiModelsOllamaV1ModelsUrlIdxGetRequest{
		ApiService: a,
		ctx: ctx,
		urlIdx: urlIdx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OllamaAPIService) GetOpenaiModelsOllamaV1ModelsUrlIdxGetExecute(r ApiGetOpenaiModelsOllamaV1ModelsUrlIdxGetRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OllamaAPIService.GetOpenaiModelsOllamaV1ModelsUrlIdxGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ollama/v1/models/{url_idx}"
	localVarPath = strings.Replace(localVarPath, "{"+"url_idx"+"}", url.PathEscape(parameterValueToString(r.urlIdx, "urlIdx")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStatusOllamaGetRequest struct {
	ctx context.Context
	ApiService *OllamaAPIService
}

func (r ApiGetStatusOllamaGetRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.GetStatusOllamaGetExecute(r)
}

/*
GetStatusOllamaGet Get Status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetStatusOllamaGetRequest
*/
func (a *OllamaAPIService) GetStatusOllamaGet(ctx context.Context) ApiGetStatusOllamaGetRequest {
	return ApiGetStatusOllamaGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OllamaAPIService) GetStatusOllamaGetExecute(r ApiGetStatusOllamaGetRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OllamaAPIService.GetStatusOllamaGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ollama/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStatusOllamaHeadRequest struct {
	ctx context.Context
	ApiService *OllamaAPIService
}

func (r ApiGetStatusOllamaHeadRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.GetStatusOllamaHeadExecute(r)
}

/*
GetStatusOllamaHead Get Status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetStatusOllamaHeadRequest
*/
func (a *OllamaAPIService) GetStatusOllamaHead(ctx context.Context) ApiGetStatusOllamaHeadRequest {
	return ApiGetStatusOllamaHeadRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OllamaAPIService) GetStatusOllamaHeadExecute(r ApiGetStatusOllamaHeadRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OllamaAPIService.GetStatusOllamaHead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ollama/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPullModelOllamaApiPullPostRequest struct {
	ctx context.Context
	ApiService *OllamaAPIService
	modelNameForm *ModelNameForm
	urlIdx *int32
}

func (r ApiPullModelOllamaApiPullPostRequest) ModelNameForm(modelNameForm ModelNameForm) ApiPullModelOllamaApiPullPostRequest {
	r.modelNameForm = &modelNameForm
	return r
}

func (r ApiPullModelOllamaApiPullPostRequest) UrlIdx(urlIdx int32) ApiPullModelOllamaApiPullPostRequest {
	r.urlIdx = &urlIdx
	return r
}

func (r ApiPullModelOllamaApiPullPostRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.PullModelOllamaApiPullPostExecute(r)
}

/*
PullModelOllamaApiPullPost Pull Model

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPullModelOllamaApiPullPostRequest
*/
func (a *OllamaAPIService) PullModelOllamaApiPullPost(ctx context.Context) ApiPullModelOllamaApiPullPostRequest {
	return ApiPullModelOllamaApiPullPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OllamaAPIService) PullModelOllamaApiPullPostExecute(r ApiPullModelOllamaApiPullPostRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OllamaAPIService.PullModelOllamaApiPullPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ollama/api/pull"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelNameForm == nil {
		return localVarReturnValue, nil, reportError("modelNameForm is required and must be specified")
	}

	if r.urlIdx != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "url_idx", r.urlIdx, "form", "")
	} else {
		var defaultValue int32 = 0
		r.urlIdx = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelNameForm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPullModelOllamaApiPullUrlIdxPostRequest struct {
	ctx context.Context
	ApiService *OllamaAPIService
	urlIdx int32
	modelNameForm *ModelNameForm
}

func (r ApiPullModelOllamaApiPullUrlIdxPostRequest) ModelNameForm(modelNameForm ModelNameForm) ApiPullModelOllamaApiPullUrlIdxPostRequest {
	r.modelNameForm = &modelNameForm
	return r
}

func (r ApiPullModelOllamaApiPullUrlIdxPostRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.PullModelOllamaApiPullUrlIdxPostExecute(r)
}

/*
PullModelOllamaApiPullUrlIdxPost Pull Model

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param urlIdx
 @return ApiPullModelOllamaApiPullUrlIdxPostRequest
*/
func (a *OllamaAPIService) PullModelOllamaApiPullUrlIdxPost(ctx context.Context, urlIdx int32) ApiPullModelOllamaApiPullUrlIdxPostRequest {
	return ApiPullModelOllamaApiPullUrlIdxPostRequest{
		ApiService: a,
		ctx: ctx,
		urlIdx: urlIdx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OllamaAPIService) PullModelOllamaApiPullUrlIdxPostExecute(r ApiPullModelOllamaApiPullUrlIdxPostRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OllamaAPIService.PullModelOllamaApiPullUrlIdxPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ollama/api/pull/{url_idx}"
	localVarPath = strings.Replace(localVarPath, "{"+"url_idx"+"}", url.PathEscape(parameterValueToString(r.urlIdx, "urlIdx")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelNameForm == nil {
		return localVarReturnValue, nil, reportError("modelNameForm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelNameForm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPushModelOllamaApiPushDeleteRequest struct {
	ctx context.Context
	ApiService *OllamaAPIService
	pushModelForm *PushModelForm
	urlIdx *int32
}

func (r ApiPushModelOllamaApiPushDeleteRequest) PushModelForm(pushModelForm PushModelForm) ApiPushModelOllamaApiPushDeleteRequest {
	r.pushModelForm = &pushModelForm
	return r
}

func (r ApiPushModelOllamaApiPushDeleteRequest) UrlIdx(urlIdx int32) ApiPushModelOllamaApiPushDeleteRequest {
	r.urlIdx = &urlIdx
	return r
}

func (r ApiPushModelOllamaApiPushDeleteRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.PushModelOllamaApiPushDeleteExecute(r)
}

/*
PushModelOllamaApiPushDelete Push Model

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPushModelOllamaApiPushDeleteRequest
*/
func (a *OllamaAPIService) PushModelOllamaApiPushDelete(ctx context.Context) ApiPushModelOllamaApiPushDeleteRequest {
	return ApiPushModelOllamaApiPushDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OllamaAPIService) PushModelOllamaApiPushDeleteExecute(r ApiPushModelOllamaApiPushDeleteRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OllamaAPIService.PushModelOllamaApiPushDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ollama/api/push"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pushModelForm == nil {
		return localVarReturnValue, nil, reportError("pushModelForm is required and must be specified")
	}

	if r.urlIdx != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "url_idx", r.urlIdx, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pushModelForm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPushModelOllamaApiPushUrlIdxDeleteRequest struct {
	ctx context.Context
	ApiService *OllamaAPIService
	urlIdx int32
	pushModelForm *PushModelForm
}

func (r ApiPushModelOllamaApiPushUrlIdxDeleteRequest) PushModelForm(pushModelForm PushModelForm) ApiPushModelOllamaApiPushUrlIdxDeleteRequest {
	r.pushModelForm = &pushModelForm
	return r
}

func (r ApiPushModelOllamaApiPushUrlIdxDeleteRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.PushModelOllamaApiPushUrlIdxDeleteExecute(r)
}

/*
PushModelOllamaApiPushUrlIdxDelete Push Model

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param urlIdx
 @return ApiPushModelOllamaApiPushUrlIdxDeleteRequest
*/
func (a *OllamaAPIService) PushModelOllamaApiPushUrlIdxDelete(ctx context.Context, urlIdx int32) ApiPushModelOllamaApiPushUrlIdxDeleteRequest {
	return ApiPushModelOllamaApiPushUrlIdxDeleteRequest{
		ApiService: a,
		ctx: ctx,
		urlIdx: urlIdx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OllamaAPIService) PushModelOllamaApiPushUrlIdxDeleteExecute(r ApiPushModelOllamaApiPushUrlIdxDeleteRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OllamaAPIService.PushModelOllamaApiPushUrlIdxDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ollama/api/push/{url_idx}"
	localVarPath = strings.Replace(localVarPath, "{"+"url_idx"+"}", url.PathEscape(parameterValueToString(r.urlIdx, "urlIdx")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pushModelForm == nil {
		return localVarReturnValue, nil, reportError("pushModelForm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pushModelForm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiShowModelInfoOllamaApiShowPostRequest struct {
	ctx context.Context
	ApiService *OllamaAPIService
	modelNameForm *ModelNameForm
}

func (r ApiShowModelInfoOllamaApiShowPostRequest) ModelNameForm(modelNameForm ModelNameForm) ApiShowModelInfoOllamaApiShowPostRequest {
	r.modelNameForm = &modelNameForm
	return r
}

func (r ApiShowModelInfoOllamaApiShowPostRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.ShowModelInfoOllamaApiShowPostExecute(r)
}

/*
ShowModelInfoOllamaApiShowPost Show Model Info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiShowModelInfoOllamaApiShowPostRequest
*/
func (a *OllamaAPIService) ShowModelInfoOllamaApiShowPost(ctx context.Context) ApiShowModelInfoOllamaApiShowPostRequest {
	return ApiShowModelInfoOllamaApiShowPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OllamaAPIService) ShowModelInfoOllamaApiShowPostExecute(r ApiShowModelInfoOllamaApiShowPostRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OllamaAPIService.ShowModelInfoOllamaApiShowPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ollama/api/show"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelNameForm == nil {
		return localVarReturnValue, nil, reportError("modelNameForm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modelNameForm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateConfigOllamaConfigUpdatePostRequest struct {
	ctx context.Context
	ApiService *OllamaAPIService
	openWebuiRoutersOllamaOllamaConfigForm *OpenWebuiRoutersOllamaOllamaConfigForm
}

func (r ApiUpdateConfigOllamaConfigUpdatePostRequest) OpenWebuiRoutersOllamaOllamaConfigForm(openWebuiRoutersOllamaOllamaConfigForm OpenWebuiRoutersOllamaOllamaConfigForm) ApiUpdateConfigOllamaConfigUpdatePostRequest {
	r.openWebuiRoutersOllamaOllamaConfigForm = &openWebuiRoutersOllamaOllamaConfigForm
	return r
}

func (r ApiUpdateConfigOllamaConfigUpdatePostRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.UpdateConfigOllamaConfigUpdatePostExecute(r)
}

/*
UpdateConfigOllamaConfigUpdatePost Update Config

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateConfigOllamaConfigUpdatePostRequest
*/
func (a *OllamaAPIService) UpdateConfigOllamaConfigUpdatePost(ctx context.Context) ApiUpdateConfigOllamaConfigUpdatePostRequest {
	return ApiUpdateConfigOllamaConfigUpdatePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OllamaAPIService) UpdateConfigOllamaConfigUpdatePostExecute(r ApiUpdateConfigOllamaConfigUpdatePostRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OllamaAPIService.UpdateConfigOllamaConfigUpdatePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ollama/config/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.openWebuiRoutersOllamaOllamaConfigForm == nil {
		return localVarReturnValue, nil, reportError("openWebuiRoutersOllamaOllamaConfigForm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.openWebuiRoutersOllamaOllamaConfigForm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUploadModelOllamaModelsUploadPostRequest struct {
	ctx context.Context
	ApiService *OllamaAPIService
	file *os.File
	urlIdx *int32
}

func (r ApiUploadModelOllamaModelsUploadPostRequest) File(file *os.File) ApiUploadModelOllamaModelsUploadPostRequest {
	r.file = file
	return r
}

func (r ApiUploadModelOllamaModelsUploadPostRequest) UrlIdx(urlIdx int32) ApiUploadModelOllamaModelsUploadPostRequest {
	r.urlIdx = &urlIdx
	return r
}

func (r ApiUploadModelOllamaModelsUploadPostRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.UploadModelOllamaModelsUploadPostExecute(r)
}

/*
UploadModelOllamaModelsUploadPost Upload Model

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUploadModelOllamaModelsUploadPostRequest
*/
func (a *OllamaAPIService) UploadModelOllamaModelsUploadPost(ctx context.Context) ApiUploadModelOllamaModelsUploadPostRequest {
	return ApiUploadModelOllamaModelsUploadPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OllamaAPIService) UploadModelOllamaModelsUploadPostExecute(r ApiUploadModelOllamaModelsUploadPostRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OllamaAPIService.UploadModelOllamaModelsUploadPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ollama/models/upload"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.file == nil {
		return localVarReturnValue, nil, reportError("file is required and must be specified")
	}

	if r.urlIdx != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "url_idx", r.urlIdx, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var fileLocalVarFormFileName string
	var fileLocalVarFileName     string
	var fileLocalVarFileBytes    []byte

	fileLocalVarFormFileName = "file"
	fileLocalVarFile := r.file

	if fileLocalVarFile != nil {
		fbs, _ := io.ReadAll(fileLocalVarFile)

		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUploadModelOllamaModelsUploadUrlIdxPostRequest struct {
	ctx context.Context
	ApiService *OllamaAPIService
	urlIdx int32
	file *os.File
}

func (r ApiUploadModelOllamaModelsUploadUrlIdxPostRequest) File(file *os.File) ApiUploadModelOllamaModelsUploadUrlIdxPostRequest {
	r.file = file
	return r
}

func (r ApiUploadModelOllamaModelsUploadUrlIdxPostRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.UploadModelOllamaModelsUploadUrlIdxPostExecute(r)
}

/*
UploadModelOllamaModelsUploadUrlIdxPost Upload Model

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param urlIdx
 @return ApiUploadModelOllamaModelsUploadUrlIdxPostRequest
*/
func (a *OllamaAPIService) UploadModelOllamaModelsUploadUrlIdxPost(ctx context.Context, urlIdx int32) ApiUploadModelOllamaModelsUploadUrlIdxPostRequest {
	return ApiUploadModelOllamaModelsUploadUrlIdxPostRequest{
		ApiService: a,
		ctx: ctx,
		urlIdx: urlIdx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OllamaAPIService) UploadModelOllamaModelsUploadUrlIdxPostExecute(r ApiUploadModelOllamaModelsUploadUrlIdxPostRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OllamaAPIService.UploadModelOllamaModelsUploadUrlIdxPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ollama/models/upload/{url_idx}"
	localVarPath = strings.Replace(localVarPath, "{"+"url_idx"+"}", url.PathEscape(parameterValueToString(r.urlIdx, "urlIdx")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.file == nil {
		return localVarReturnValue, nil, reportError("file is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var fileLocalVarFormFileName string
	var fileLocalVarFileName     string
	var fileLocalVarFileBytes    []byte

	fileLocalVarFormFileName = "file"
	fileLocalVarFile := r.file

	if fileLocalVarFile != nil {
		fbs, _ := io.ReadAll(fileLocalVarFile)

		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVerifyConnectionOllamaVerifyPostRequest struct {
	ctx context.Context
	ApiService *OllamaAPIService
	openWebuiRoutersOllamaConnectionVerificationForm *OpenWebuiRoutersOllamaConnectionVerificationForm
}

func (r ApiVerifyConnectionOllamaVerifyPostRequest) OpenWebuiRoutersOllamaConnectionVerificationForm(openWebuiRoutersOllamaConnectionVerificationForm OpenWebuiRoutersOllamaConnectionVerificationForm) ApiVerifyConnectionOllamaVerifyPostRequest {
	r.openWebuiRoutersOllamaConnectionVerificationForm = &openWebuiRoutersOllamaConnectionVerificationForm
	return r
}

func (r ApiVerifyConnectionOllamaVerifyPostRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.VerifyConnectionOllamaVerifyPostExecute(r)
}

/*
VerifyConnectionOllamaVerifyPost Verify Connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVerifyConnectionOllamaVerifyPostRequest
*/
func (a *OllamaAPIService) VerifyConnectionOllamaVerifyPost(ctx context.Context) ApiVerifyConnectionOllamaVerifyPostRequest {
	return ApiVerifyConnectionOllamaVerifyPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OllamaAPIService) VerifyConnectionOllamaVerifyPostExecute(r ApiVerifyConnectionOllamaVerifyPostRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OllamaAPIService.VerifyConnectionOllamaVerifyPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ollama/verify"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.openWebuiRoutersOllamaConnectionVerificationForm == nil {
		return localVarReturnValue, nil, reportError("openWebuiRoutersOllamaConnectionVerificationForm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.openWebuiRoutersOllamaConnectionVerificationForm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
